<#

You'll need the powershell-yaml module (use of ConvertFrom-Yaml), installing by running this as admin:
```ps
Install-Module powershell-yaml -Force
```

You can get 

$yaml = Invoke-RestMethod https://github.com/undergroundwires/privacy.sexy/raw/master/src/application/collections/windows.yaml
$collection = $yaml | ConvertFrom-Yaml
Import-PrivacySexy

#>

$global:function_map = [ordered]@{}


function Convert-PrivacySexyToPSModule {
    param(
        [Hashtable]$collection,
        $script:module = @"
<#
    privacy.sexy ported to a PowerShell module
    This file is automatically generated by Import-PrivacySexy

    You need to have the privacy.sexy.lib.ps1 imported in order to make use of most functions.
    It is available in https://github.com/couleur-tweak-tips/TweakList

    credits: https://privacy.sexy
#>


"@
    )


    # adds 4 spaces at the start of each line
    filter Indent {
    ($PSItem -split "`n" | ForEach-Object { "`t" + $PSItem }) -join "`n"
    }

    # input: hashtable, kinda imitates splatting
    filter ConvertTo-Parameters {
        $(
            ForEach ($arg in $PSItem.Keys) {
                if ($arg -eq "True") {
                    # I love PowerShell booleans evaluating to string 'True' or 'False' !
                    "-$arg"
                }
                else {
                    "-$arg `"$($PSItem.$arg)`"" 
                }
            
            }
        ) -join ' '
    }

    function Format-Function {
        param(
            [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
            $category
        )

        $cmdlet = $category.name | ConvertTo-Cmdlet
        $global:function_map[$category.name] = $cmdlet

        Write-Output @"


<#
    .SYNOPSIS
    $($category.name)
"@


        if ($category.docs) {
            Write-Output @"

    .NOTES
$($category.docs -join "`n" | Indent)
"@  
        }

        Write-Output "`n#>"

        Write-Output "`nfunction $cmdlet {`n"
        # Wait-Debugger

        Write-Output $(& {

                $functionBody = ""

                if ($category.code -and !$category.revertcode -and !$category.calls) {
                    return "RunInlineCode @'`n$($category.code | Indent)`n'@`n"
                }
                elseif ($category.code -and $category.revertcode -and !$category.calls) {
                    return @"
param([Switch]`$Revert)
if (!`$Revert){
    RunInlineCode @'
$($category.code | Indent)
'@
} else {
    RunInlineCode @'
$($category.revertcode | Indent)
'@
}

"@
                }
                if ($category.call) {
                    foreach ($call in $category.call) {
                        # the spacing here is very important to clearly realize these are completely different blocks and situations
                        # `return` should not be used in this since 





                        if ($call.function -eq "RunInlineCode") {
                            # literally brain-fucking semi-boilerplate, it's the exact same problem but with little variations
                            if ($call.parameters.code -and !$call.parameters.revertcode) {
                                $functionBody += "RunInlineCode @'`n$($category.parameters.code | Indent)`n'@`n"
                            }
                            elseif ($call.parameters.code -and $call.parameters.revertcode) {
                                $script:needsRevertParam = $True
                                $functionBody += @"
if (!`$Revert){
    RunInlineCode @'
$($call.parameters.code | Indent)
'@
} else {
    RunInlineCode @'
$($call.parameters.revertcode | Indent)
'@
}

"@
                            }
                            else {
                                Wait-Debugger
                                Write-Host $($call | ConvertTo-Json -Depth 10) -ForegroundColor Red
                                Write-Error "Unknown RunInlineCode call type found" -ErrorAction Stop            
                            }
                        }





                        elseif ($call.function -eq "RunInlineCodeAsTrustedInstaller") {
                            # literally brain-fucking semi-boilerplate, it's the exact same problem but with little variations
                            if ($call.parameters.code -and !$call.parameters.revertcode) {
                                $functionBody += "RunInlineCodeAsTrustedInstaller @'`n$($category.parameters.code | Indent)`n'@`n"
                            }
                            elseif ($call.parameters.code -and $call.parameters.revertcode) {
                                $script:needsRevertParam = $True
                                $functionBody += @"
if (!`$Revert){
    RunInlineCodeAsTrustedInstaller @'
$($call.parameters.code | Indent)
'@
} else {
    RunInlineCodeAsTrustedInstaller @'
$($call.parameters.revertcode | Indent)
'@
}

"@
                            }
                            else {
                                Wait-Debugger
                                Write-Host $($call | ConvertTo-Json -Depth 10) -ForegroundColor Red
                                Write-Error "Unknown RunInlineCodeAsTrustedInstaller call type found" -ErrorAction Stop            
                            }
                        }





                        elseif ($call.function -eq "RunPowerShell") {
                            if ($call.parameters.code -and !$call.parameters.revertcode) {
                                $call.parameters.code
                            }
                            elseif ($call.parameters.code -and $call.parameters.revertcode) {
                                $script:needsRevertParam = $True
                                $functionBody += @"
if (!`$Revert){
$($call.parameters.code | Indent)
} else {
$($call.parameters.revertcode | Indent)
}

"@
                            }
                            else {
                                Write-Host $($call | ConvertTo-Json -Depth 10) -ForegroundColor Red
                                Write-Error "Unknown call type found" -ErrorAction Stop            
                            }
                        }

                        else {
                            $functionBody += $call.function + ' ' + ($call.parameters | ConvertTo-Parameters) + "`n"
                        }

                    } # foreach call

                }
                else {
                    Write-Host $($category | ConvertTo-Json -Depth 10) -ForegroundColor Red
                    Write-Error "Unknown category type found" -ErrorAction Stop
                }
                if ($script:needsRevertParam) {
                    $functionBody = "param([Switch]`$Revert)`n`n" + $functionBody 
                    Remove-Variable needsRevertParam -Scope script
                }
                Write-Output $functionBody
                Remove-Variable functionBody # bless the PowerShell pipeline
            })

        Write-Output "}" # final function close
    }

    ######################

    $valid_verbs = (Get-Verb).Verb
    $replace_map = @{
        Delete     = 'Remove'
        'Turn Off' = 'Disable'
        Refuse     = 'Deny'
        Increase   = 'Expand'
        '2.0'      = '2'
        '&'        = 'and'
        '\.'       = '' # remove any dots
        '-'        = ''
        '/'        = ''
        '"'        = ''
        ','        = ''
        "'"        = ""
    }
    filter ConvertTo-Cmdlet {

        $cleaned = $_ -replace '\([^)]*\)', '' -replace '[^\w\s]', '' -replace '\s+', ' ' 
        # remove quotes and whatever's in between
        # remove non alpha-numerical chars
        # replaces any trailing spaces by a single one

        foreach ($key in $replace_map.Keys) {
            $cleaned = $cleaned -replace $key, $replace_map.$key
        }

        $verb, $nouns = (Get-Culture).TextInfo.ToTitleCase($cleaned) -split '\s'
        # thanks chris :yay:
        if ($verb -in $valid_verbs) {
            return '{0}-{1}' -f $verb, (-join $nouns)
        }
        else {
            return '{0}{1}' -f $verb, (-join $nouns)
        }
    }

    function Get-Category ([Hashtable]$category) {
        # Wait-Debugger
        if ($category.keys -contains 'children') {
            if ($category.category -in $collection.actions.category) {
                $catlength = $category.category.length + 8 # s/o atzur the big coat (cat goat)
                $script:module += "`n" + "#" * $catlength
                $script:module += "#" * $catlength
                $script:module += "#region $($category.category.ToUpper())"
                $script:module += "#" * $catlength
                $script:module += "#" * $catlength + "`n"
            }
            else {
                $script:module += "#region $($category.category)"
            }
            foreach ($child in $category.children) {
                Get-Category $child # recursively call
            }
            $script:module += "#endregion`n"
        }
        else {
            # $global:categories += $category
            $script:module += (Format-Function $category)
        }
    }

    foreach ($category in $collection.actions) {
        Get-Category $category
    }

    return $script:module
}